{
  "project": {
    "name": "Jobsity Chat",
    "id": "jobsity-chat",
    "description": "Real-time browser-based chat application with stock quote bot integration",
    "version": "1.0.0",
    "created_at": "2026-01-28"
  },
  "go": {
    "version": "1.21+",
    "modules": true,
    "build_flags": [
      "-trimpath",
      "-ldflags=-s -w"
    ],
    "linter": "golangci-lint",
    "formatter": "gofmt"
  },
  "business": {
    "problem": "Create a simple browser-based chat application that allows multiple users to communicate in real-time and retrieve stock quotes via commands",
    "stakeholders": [
      "Jobsity (evaluation team)",
      "End users (chat participants)"
    ],
    "success_metrics": [
      "Multiple users can chat in real-time",
      "Stock command returns accurate quotes within 5 seconds",
      "Messages ordered by timestamp (newest last)",
      "Last 50 messages displayed",
      "No resource leaks under concurrent usage",
      "Unit tests demonstrate code quality"
    ],
    "constraints": [
      "Backend-focused (minimal frontend)",
      "Stock commands not saved to database",
      "Must use RabbitMQ for bot communication",
      "Must handle 2+ concurrent browser sessions"
    ]
  },
  "architecture": {
    "pattern": "microservices",
    "services": [
      {
        "name": "chat-server",
        "purpose": "Main chat server with WebSocket support",
        "responsibilities": [
          "User authentication and session management",
          "WebSocket connection handling",
          "Message persistence and retrieval",
          "Command detection and routing",
          "Real-time message broadcasting"
        ]
      },
      {
        "name": "stock-bot",
        "purpose": "Decoupled bot for stock quote retrieval",
        "responsibilities": [
          "Consume stock command messages from RabbitMQ",
          "Fetch stock data from Stooq API",
          "Parse CSV response",
          "Publish formatted quote back to RabbitMQ"
        ]
      }
    ],
    "layers": [
      "Handler (HTTP/WebSocket endpoints)",
      "Service (business logic)",
      "Repository (data access)",
      "Domain (entities and interfaces)"
    ],
    "communication": {
      "internal": "RabbitMQ message broker",
      "external": "Stooq API (CSV over HTTP)",
      "client": "WebSocket for real-time, HTTP for auth"
    }
  },
  "database": {
    "type": "PostgreSQL",
    "version": "15+",
    "schema": {
      "tables": [
        {
          "name": "users",
          "columns": [
            "id UUID PRIMARY KEY DEFAULT gen_random_uuid()",
            "username VARCHAR(50) UNIQUE NOT NULL",
            "email VARCHAR(255) UNIQUE NOT NULL",
            "password_hash VARCHAR(255) NOT NULL",
            "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
          ],
          "indexes": [
            "CREATE INDEX idx_users_username ON users(username)",
            "CREATE INDEX idx_users_email ON users(email)"
          ]
        },
        {
          "name": "chatrooms",
          "columns": [
            "id UUID PRIMARY KEY DEFAULT gen_random_uuid()",
            "name VARCHAR(100) NOT NULL",
            "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP",
            "created_by UUID REFERENCES users(id)"
          ],
          "indexes": [
            "CREATE INDEX idx_chatrooms_name ON chatrooms(name)"
          ]
        },
        {
          "name": "messages",
          "columns": [
            "id UUID PRIMARY KEY DEFAULT gen_random_uuid()",
            "chatroom_id UUID NOT NULL REFERENCES chatrooms(id) ON DELETE CASCADE",
            "user_id UUID NOT NULL REFERENCES users(id)",
            "content TEXT NOT NULL",
            "is_bot BOOLEAN DEFAULT FALSE",
            "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
          ],
          "indexes": [
            "CREATE INDEX idx_messages_chatroom_created ON messages(chatroom_id, created_at DESC)",
            "CREATE INDEX idx_messages_created_at ON messages(created_at DESC)"
          ]
        },
        {
          "name": "chatroom_members",
          "columns": [
            "user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE",
            "chatroom_id UUID NOT NULL REFERENCES chatrooms(id) ON DELETE CASCADE",
            "joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP",
            "PRIMARY KEY (user_id, chatroom_id)"
          ],
          "indexes": [
            "CREATE INDEX idx_members_chatroom ON chatroom_members(chatroom_id)"
          ]
        }
      ]
    },
    "migrations": {
      "tool": "golang-migrate/migrate",
      "path": "./migrations",
      "naming": "{version}_{description}.up.sql / .down.sql"
    },
    "connection": {
      "pool_size": 25,
      "max_idle": 5,
      "max_lifetime": "5m",
      "driver": "lib/pq"
    }
  },
  "api": {
    "style": "REST + WebSocket",
    "base_path": "/api/v1",
    "endpoints": {
      "rest": [
        {
          "method": "POST",
          "path": "/auth/register",
          "description": "Register new user",
          "request": {
            "username": "string",
            "email": "string",
            "password": "string"
          },
          "response": {
            "user_id": "uuid",
            "username": "string"
          }
        },
        {
          "method": "POST",
          "path": "/auth/login",
          "description": "Login user and create session",
          "request": {
            "username": "string",
            "password": "string"
          },
          "response": {
            "success": "boolean"
          },
          "sets_cookie": "session_id"
        },
        {
          "method": "POST",
          "path": "/auth/logout",
          "description": "Logout user and destroy session"
        },
        {
          "method": "GET",
          "path": "/chatrooms",
          "description": "List available chatrooms",
          "auth_required": true
        },
        {
          "method": "POST",
          "path": "/chatrooms",
          "description": "Create new chatroom",
          "auth_required": true
        },
        {
          "method": "GET",
          "path": "/chatrooms/{id}/messages",
          "description": "Get last 50 messages for chatroom",
          "auth_required": true,
          "query_params": {
            "limit": "50 (default)"
          }
        }
      ],
      "websocket": [
        {
          "path": "/ws/chat/{chatroom_id}",
          "description": "WebSocket connection for real-time chat",
          "auth_required": true,
          "messages": {
            "client_to_server": [
              {
                "type": "chat_message",
                "payload": {
                  "content": "string"
                }
              },
              {
                "type": "stock_command",
                "payload": {
                  "stock_code": "string"
                },
                "format": "/stock=AAPL.US"
              }
            ],
            "server_to_client": [
              {
                "type": "chat_message",
                "payload": {
                  "id": "uuid",
                  "user_id": "uuid",
                  "username": "string",
                  "content": "string",
                  "is_bot": "boolean",
                  "created_at": "timestamp"
                }
              },
              {
                "type": "user_joined",
                "payload": {
                  "username": "string"
                }
              },
              {
                "type": "user_left",
                "payload": {
                  "username": "string"
                }
              },
              {
                "type": "error",
                "payload": {
                  "message": "string"
                }
              }
            ]
          }
        }
      ]
    },
    "authentication": {
      "method": "session-based",
      "session_storage": "PostgreSQL (sessions table)",
      "cookie": {
        "name": "session_id",
        "httponly": true,
        "secure": true,
        "samesite": "strict",
        "max_age": "24h"
      }
    }
  },
  "messaging": {
    "broker": "RabbitMQ",
    "version": "3.12+",
    "exchanges": [
      {
        "name": "chat.commands",
        "type": "topic",
        "durable": true
      },
      {
        "name": "chat.responses",
        "type": "fanout",
        "durable": true
      }
    ],
    "queues": [
      {
        "name": "stock.commands",
        "binding": {
          "exchange": "chat.commands",
          "routing_key": "stock.request"
        },
        "consumer": "stock-bot"
      },
      {
        "name": "stock.responses.{chatroom_id}",
        "binding": {
          "exchange": "chat.responses",
          "routing_key": ""
        },
        "consumer": "chat-server",
        "auto_delete": true
      }
    ],
    "message_formats": {
      "stock_request": {
        "chatroom_id": "uuid",
        "stock_code": "string",
        "requested_by": "string",
        "timestamp": "int64"
      },
      "stock_response": {
        "chatroom_id": "uuid",
        "symbol": "string",
        "price": "float64",
        "formatted_message": "string",
        "error": "string (optional)",
        "timestamp": "int64"
      }
    }
  },
  "external_apis": {
    "stooq": {
      "base_url": "https://stooq.com",
      "endpoint": "/q/l/",
      "params": {
        "s": "stock_code (e.g., aapl.us)",
        "f": "sd2t2ohlcv",
        "h": "",
        "e": "csv"
      },
      "response_format": "CSV",
      "csv_columns": [
        "Symbol",
        "Date",
        "Time",
        "Open",
        "High",
        "Low",
        "Close",
        "Volume"
      ],
      "timeout": "10s",
      "retry": {
        "max_attempts": 3,
        "backoff": "exponential"
      }
    }
  },
  "middleware": [
    {
      "name": "Logger",
      "purpose": "HTTP request/response logging",
      "library": "chi/middleware or custom"
    },
    {
      "name": "Recoverer",
      "purpose": "Panic recovery",
      "library": "chi/middleware"
    },
    {
      "name": "CORS",
      "purpose": "Cross-origin resource sharing",
      "config": {
        "allowed_origins": ["http://localhost:3000"],
        "allowed_methods": ["GET", "POST", "PUT", "DELETE"],
        "allowed_headers": ["Content-Type", "Authorization"]
      }
    },
    {
      "name": "Auth",
      "purpose": "Session validation",
      "applies_to": ["protected routes", "WebSocket upgrade"]
    },
    {
      "name": "RateLimiter",
      "purpose": "Rate limiting per user",
      "config": {
        "requests_per_minute": 60
      }
    }
  ],
  "dependencies": {
    "core": [
      {
        "name": "github.com/go-chi/chi/v5",
        "purpose": "HTTP router",
        "reason": "Lightweight, idiomatic, great middleware support"
      },
      {
        "name": "github.com/gorilla/websocket",
        "purpose": "WebSocket support",
        "reason": "Industry standard, battle-tested"
      },
      {
        "name": "github.com/lib/pq",
        "purpose": "PostgreSQL driver",
        "reason": "Pure Go, well-maintained"
      },
      {
        "name": "github.com/rabbitmq/amqp091-go",
        "purpose": "RabbitMQ client",
        "reason": "Official RabbitMQ Go client"
      }
    ],
    "utilities": [
      {
        "name": "github.com/google/uuid",
        "purpose": "UUID generation"
      },
      {
        "name": "golang.org/x/crypto/bcrypt",
        "purpose": "Password hashing"
      },
      {
        "name": "github.com/joho/godotenv",
        "purpose": "Environment variable loading"
      }
    ],
    "testing": [
      {
        "name": "github.com/stretchr/testify",
        "purpose": "Assertions and mocks"
      },
      {
        "name": "github.com/testcontainers/testcontainers-go",
        "purpose": "Integration testing with containers"
      }
    ]
  },
  "testing": {
    "strategy": {
      "unit_tests": [
        "Command parsing (/stock= detection)",
        "CSV parsing from Stooq API",
        "Message formatting",
        "Password hashing/verification",
        "Session validation"
      ],
      "integration_tests": [
        "Database operations (CRUD messages, users)",
        "RabbitMQ message flow",
        "WebSocket connection lifecycle",
        "Authentication flow"
      ],
      "e2e_tests": [
        "Full chat flow: login → join → send → receive",
        "Stock command flow: send command → bot responds",
        "Multi-user scenario: 2 users chatting"
      ]
    },
    "coverage_target": "70%+",
    "test_commands": [
      "make test (unit tests)",
      "make test-integration (with test containers)",
      "make coverage (generate coverage report)"
    ]
  },
  "observability": {
    "logging": {
      "library": "slog (Go 1.21+)",
      "format": "JSON",
      "levels": ["DEBUG", "INFO", "WARN", "ERROR"],
      "contexts": [
        "HTTP requests (method, path, status, duration)",
        "WebSocket connections (connect, disconnect)",
        "RabbitMQ messages (sent, received)",
        "External API calls (Stooq)",
        "Errors and panics"
      ]
    },
    "metrics": {
      "library": "prometheus/client_golang",
      "metrics": [
        "http_requests_total (counter)",
        "http_request_duration_seconds (histogram)",
        "websocket_connections_active (gauge)",
        "messages_sent_total (counter)",
        "stock_requests_total (counter)",
        "stock_request_duration_seconds (histogram)",
        "rabbitmq_messages_published_total (counter)",
        "rabbitmq_messages_consumed_total (counter)"
      ]
    },
    "health_checks": [
      {
        "path": "/health",
        "checks": ["server_up"]
      },
      {
        "path": "/health/ready",
        "checks": ["database_connection", "rabbitmq_connection"]
      }
    ]
  },
  "deployment": {
    "containers": {
      "chat-server": {
        "image": "jobsity-chat:latest",
        "port": 8080,
        "env": [
          "DATABASE_URL",
          "RABBITMQ_URL",
          "SESSION_SECRET"
        ]
      },
      "stock-bot": {
        "image": "stock-bot:latest",
        "env": [
          "RABBITMQ_URL",
          "STOOQ_API_URL"
        ]
      },
      "postgres": {
        "image": "postgres:15-alpine",
        "port": 5432
      },
      "rabbitmq": {
        "image": "rabbitmq:3.12-management-alpine",
        "ports": [5672, 15672]
      }
    },
    "docker_compose": true,
    "kubernetes": {
      "deployments": [
        "chat-server (2 replicas)",
        "stock-bot (1 replica)",
        "postgres (statefulset)",
        "rabbitmq (statefulset)"
      ],
      "services": [
        "chat-server (LoadBalancer)",
        "postgres (ClusterIP)",
        "rabbitmq (ClusterIP)"
      ],
      "configmaps": ["app-config"],
      "secrets": ["db-credentials", "rabbitmq-credentials"]
    }
  },
  "security": {
    "authentication": {
      "method": "session-based with secure cookies",
      "password_hashing": "bcrypt (cost 12)"
    },
    "authorization": {
      "model": "simple membership check",
      "rules": [
        "Users can only access chatrooms they are members of",
        "Users must be authenticated for all WebSocket connections"
      ]
    },
    "input_validation": [
      "Username: alphanumeric, 3-50 chars",
      "Email: valid email format",
      "Password: min 8 chars",
      "Message content: max 1000 chars",
      "Stock code: alphanumeric with dots, max 20 chars"
    ],
    "rate_limiting": {
      "login_attempts": "5 per 5 minutes per IP",
      "messages": "60 per minute per user",
      "stock_commands": "10 per minute per user"
    },
    "cors": {
      "allowed_origins": ["http://localhost:3000"],
      "credentials": true
    }
  },
  "performance": {
    "targets": {
      "message_latency": "<100ms (WebSocket broadcast)",
      "stock_quote_latency": "<5s (end-to-end)",
      "concurrent_connections": "100+ per chat-server instance",
      "messages_per_second": "1000+"
    },
    "optimizations": [
      "Database connection pooling",
      "RabbitMQ channel pooling",
      "Efficient WebSocket hub with goroutines",
      "Index on messages(chatroom_id, created_at DESC)",
      "Limited message retrieval (50 messages)",
      "Context-based cancellation for graceful shutdown"
    ],
    "caching": {
      "strategy": "minimal (real-time priority)",
      "potential": "User sessions in Redis (optional optimization)"
    }
  },
  "implementation": {
    "phases": [
      {
        "phase": 1,
        "name": "Project Setup",
        "tasks": [
          "Initialize Go module",
          "Setup directory structure",
          "Create Dockerfile and docker-compose.yml",
          "Configure environment variables",
          "Setup database migrations"
        ]
      },
      {
        "phase": 2,
        "name": "Database Layer",
        "tasks": [
          "Create database schema and migrations",
          "Implement repository interfaces",
          "Implement PostgreSQL repositories",
          "Write repository unit tests"
        ]
      },
      {
        "phase": 3,
        "name": "Domain & Service Layer",
        "tasks": [
          "Define domain entities (User, Message, Chatroom)",
          "Implement authentication service",
          "Implement chat service",
          "Implement command parser",
          "Write service unit tests"
        ]
      },
      {
        "phase": 4,
        "name": "HTTP & WebSocket Layer",
        "tasks": [
          "Implement HTTP handlers (auth, chatroom APIs)",
          "Implement WebSocket hub pattern",
          "Implement WebSocket handlers",
          "Implement middleware (auth, logging, CORS)",
          "Write handler tests"
        ]
      },
      {
        "phase": 5,
        "name": "RabbitMQ Integration",
        "tasks": [
          "Implement RabbitMQ connection manager",
          "Implement message publisher (chat-server)",
          "Implement message consumer (chat-server)",
          "Write RabbitMQ integration tests"
        ]
      },
      {
        "phase": 6,
        "name": "Stock Bot",
        "tasks": [
          "Implement Stooq API client",
          "Implement CSV parser",
          "Implement RabbitMQ consumer (stock-bot)",
          "Implement RabbitMQ publisher (stock-bot)",
          "Handle errors and edge cases",
          "Write bot unit and integration tests"
        ]
      },
      {
        "phase": 7,
        "name": "Frontend (Minimal)",
        "tasks": [
          "Create simple HTML/JS chat UI",
          "Implement WebSocket client",
          "Implement login/register forms",
          "Display last 50 messages ordered by timestamp"
        ]
      },
      {
        "phase": 8,
        "name": "Testing & Quality",
        "tasks": [
          "Complete unit test coverage",
          "Write integration tests with testcontainers",
          "Write E2E tests (2 users chatting)",
          "Test stock command flow",
          "Run linter and fix issues",
          "Performance testing"
        ]
      },
      {
        "phase": 9,
        "name": "Deployment",
        "tasks": [
          "Build Docker images",
          "Test docker-compose deployment",
          "Create Kubernetes manifests (optional)",
          "Setup CI/CD (optional)",
          "Documentation"
        ]
      }
    ]
  },
  "qa": {
    "checklist": [
      "✅ Users can register and login",
      "✅ Multiple users can connect to chatroom",
      "✅ Messages broadcast in real-time to all users",
      "✅ Messages ordered by timestamp (oldest first)",
      "✅ Only last 50 messages displayed",
      "✅ /stock=CODE command detected and parsed",
      "✅ Stock command not saved to database",
      "✅ Stock bot receives command via RabbitMQ",
      "✅ Stock bot fetches data from Stooq API",
      "✅ Stock bot parses CSV correctly",
      "✅ Stock bot publishes formatted quote via RabbitMQ",
      "✅ Stock quote appears in chat as bot message",
      "✅ Stock quote format: 'AAPL.US quote is $93.42 per share'",
      "✅ Invalid stock codes handled gracefully",
      "✅ API errors handled without crashing",
      "✅ Unit tests written for key functionality",
      "✅ Integration tests cover RabbitMQ flow",
      "✅ No resource leaks (goroutines, connections)",
      "✅ Graceful shutdown implemented",
      "✅ 2 browser windows can chat simultaneously",
      "✅ Frontend is minimal and functional",
      "✅ Code is clean and follows Go idioms",
      "✅ Git repository with commit history"
    ]
  },
  "bonus_features": {
    "implemented": [],
    "available": [
      {
        "name": "Multiple Chatrooms",
        "description": "Allow users to create and join different chatrooms",
        "effort": "Medium",
        "changes": [
          "UI for chatroom selection",
          "Chatroom CRUD endpoints",
          "WebSocket per chatroom",
          "RabbitMQ queue per chatroom"
        ]
      },
      {
        "name": "Bot Error Handling",
        "description": "Handle invalid commands and API errors gracefully",
        "effort": "Low",
        "changes": [
          "Parse command validation",
          "API error detection",
          "User-friendly error messages",
          "Log errors for debugging"
        ]
      }
    ]
  },
  "confidence_score": 9,
  "confidence_reasoning": "Complete specification with clear architecture, all requirements addressed, realistic technical choices, comprehensive testing strategy, production-ready patterns"
}
